/**
 * Generated by orval v6.11.1 üç∫
 * Do not edit manually.
 * ShortAI
 * OpenAPI spec version: 0.1.0
 */
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query'
import { useMutation, useQuery } from '@tanstack/react-query'
import type { AxiosError, AxiosRequestConfig, AxiosResponse } from 'axios'
import axios from 'axios'

import type {
  BodyCreateFileTasksTaskIdUploadFilePost,
  BodyLoginForAccessTokenAuthTokenPost,
  HTTPValidationError,
  RoutersAuthUser,
  SchemasUserUser,
  TaskIn,
  TaskOut,
  Token
} from './models'

/**
 * @summary Create User
 */
export const createUserUsersPost = (
  schemasUserUser: SchemasUserUser,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<unknown>> => {
  return axios.post(`/users`, schemasUserUser, options)
}

export type CreateUserUsersPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createUserUsersPost>>
>
export type CreateUserUsersPostMutationBody = SchemasUserUser
export type CreateUserUsersPostMutationError = AxiosError<HTTPValidationError>

export const useCreateUserUsersPost = <
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createUserUsersPost>>,
    TError,
    { data: SchemasUserUser },
    TContext
  >
  axios?: AxiosRequestConfig
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createUserUsersPost>>,
    { data: SchemasUserUser }
  > = (props) => {
    const { data } = props ?? {}

    return createUserUsersPost(data, axiosOptions)
  }

  return useMutation<
    Awaited<ReturnType<typeof createUserUsersPost>>,
    TError,
    { data: SchemasUserUser },
    TContext
  >(mutationFn, mutationOptions)
}

/**
 * @summary Get Tasks
 */
export const getTasksTasksGet = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<TaskOut[]>> => {
  return axios.get(`/tasks`, options)
}

export const getGetTasksTasksGetQueryKey = () => [`/tasks`]

export type GetTasksTasksGetQueryResult = NonNullable<Awaited<ReturnType<typeof getTasksTasksGet>>>
export type GetTasksTasksGetQueryError = AxiosError<unknown>

export const useGetTasksTasksGet = <
  TData = Awaited<ReturnType<typeof getTasksTasksGet>>,
  TError = AxiosError<unknown>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getTasksTasksGet>>, TError, TData>
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetTasksTasksGetQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTasksTasksGet>>> = ({ signal }) =>
    getTasksTasksGet({ signal, ...axiosOptions })

  const query = useQuery<Awaited<ReturnType<typeof getTasksTasksGet>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

/**
 * @summary Create Task
 */
export const createTaskTasksPost = (
  taskIn: TaskIn,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<TaskOut>> => {
  return axios.post(`/tasks`, taskIn, options)
}

export type CreateTaskTasksPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createTaskTasksPost>>
>
export type CreateTaskTasksPostMutationBody = TaskIn
export type CreateTaskTasksPostMutationError = AxiosError<HTTPValidationError>

export const useCreateTaskTasksPost = <
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createTaskTasksPost>>,
    TError,
    { data: TaskIn },
    TContext
  >
  axios?: AxiosRequestConfig
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createTaskTasksPost>>,
    { data: TaskIn }
  > = (props) => {
    const { data } = props ?? {}

    return createTaskTasksPost(data, axiosOptions)
  }

  return useMutation<
    Awaited<ReturnType<typeof createTaskTasksPost>>,
    TError,
    { data: TaskIn },
    TContext
  >(mutationFn, mutationOptions)
}

/**
 * @summary Get Task
 */
export const getTaskTasksTaskIdGet = (
  taskId: number,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<TaskOut>> => {
  return axios.get(`/tasks/${taskId}`, options)
}

export const getGetTaskTasksTaskIdGetQueryKey = (taskId: number) => [`/tasks/${taskId}`]

export type GetTaskTasksTaskIdGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTaskTasksTaskIdGet>>
>
export type GetTaskTasksTaskIdGetQueryError = AxiosError<HTTPValidationError>

export const useGetTaskTasksTaskIdGet = <
  TData = Awaited<ReturnType<typeof getTaskTasksTaskIdGet>>,
  TError = AxiosError<HTTPValidationError>
>(
  taskId: number,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getTaskTasksTaskIdGet>>, TError, TData>
    axios?: AxiosRequestConfig
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetTaskTasksTaskIdGetQueryKey(taskId)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTaskTasksTaskIdGet>>> = ({ signal }) =>
    getTaskTasksTaskIdGet(taskId, { signal, ...axiosOptions })

  const query = useQuery<Awaited<ReturnType<typeof getTaskTasksTaskIdGet>>, TError, TData>(
    queryKey,
    queryFn,
    { enabled: !!taskId, ...queryOptions }
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

/**
 * @summary Create File
 */
export const createFileTasksTaskIdUploadFilePost = (
  taskId: number,
  bodyCreateFileTasksTaskIdUploadFilePost: BodyCreateFileTasksTaskIdUploadFilePost,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<unknown>> => {
  const formData = new FormData()
  formData.append('file', bodyCreateFileTasksTaskIdUploadFilePost.file)

  return axios.post(`/tasks/${taskId}/upload_file`, formData, options)
}

export type CreateFileTasksTaskIdUploadFilePostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createFileTasksTaskIdUploadFilePost>>
>
export type CreateFileTasksTaskIdUploadFilePostMutationBody =
  BodyCreateFileTasksTaskIdUploadFilePost
export type CreateFileTasksTaskIdUploadFilePostMutationError = AxiosError<HTTPValidationError>

export const useCreateFileTasksTaskIdUploadFilePost = <
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createFileTasksTaskIdUploadFilePost>>,
    TError,
    { taskId: number; data: BodyCreateFileTasksTaskIdUploadFilePost },
    TContext
  >
  axios?: AxiosRequestConfig
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createFileTasksTaskIdUploadFilePost>>,
    { taskId: number; data: BodyCreateFileTasksTaskIdUploadFilePost }
  > = (props) => {
    const { taskId, data } = props ?? {}

    return createFileTasksTaskIdUploadFilePost(taskId, data, axiosOptions)
  }

  return useMutation<
    Awaited<ReturnType<typeof createFileTasksTaskIdUploadFilePost>>,
    TError,
    { taskId: number; data: BodyCreateFileTasksTaskIdUploadFilePost },
    TContext
  >(mutationFn, mutationOptions)
}

/**
 * @summary Login For Access Token
 */
export const loginForAccessTokenAuthTokenPost = (
  bodyLoginForAccessTokenAuthTokenPost: BodyLoginForAccessTokenAuthTokenPost,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<Token>> => {
  const formUrlEncoded = new URLSearchParams()
  if (bodyLoginForAccessTokenAuthTokenPost.grant_type !== undefined) {
    formUrlEncoded.append('grant_type', bodyLoginForAccessTokenAuthTokenPost.grant_type)
  }
  formUrlEncoded.append('username', bodyLoginForAccessTokenAuthTokenPost.username)
  formUrlEncoded.append('password', bodyLoginForAccessTokenAuthTokenPost.password)
  if (bodyLoginForAccessTokenAuthTokenPost.scope !== undefined) {
    formUrlEncoded.append('scope', bodyLoginForAccessTokenAuthTokenPost.scope)
  }
  if (bodyLoginForAccessTokenAuthTokenPost.client_id !== undefined) {
    formUrlEncoded.append('client_id', bodyLoginForAccessTokenAuthTokenPost.client_id)
  }
  if (bodyLoginForAccessTokenAuthTokenPost.client_secret !== undefined) {
    formUrlEncoded.append('client_secret', bodyLoginForAccessTokenAuthTokenPost.client_secret)
  }

  return axios.post(`/auth/token`, formUrlEncoded, options)
}

export type LoginForAccessTokenAuthTokenPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof loginForAccessTokenAuthTokenPost>>
>
export type LoginForAccessTokenAuthTokenPostMutationBody = BodyLoginForAccessTokenAuthTokenPost
export type LoginForAccessTokenAuthTokenPostMutationError = AxiosError<HTTPValidationError>

export const useLoginForAccessTokenAuthTokenPost = <
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof loginForAccessTokenAuthTokenPost>>,
    TError,
    { data: BodyLoginForAccessTokenAuthTokenPost },
    TContext
  >
  axios?: AxiosRequestConfig
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof loginForAccessTokenAuthTokenPost>>,
    { data: BodyLoginForAccessTokenAuthTokenPost }
  > = (props) => {
    const { data } = props ?? {}

    return loginForAccessTokenAuthTokenPost(data, axiosOptions)
  }

  return useMutation<
    Awaited<ReturnType<typeof loginForAccessTokenAuthTokenPost>>,
    TError,
    { data: BodyLoginForAccessTokenAuthTokenPost },
    TContext
  >(mutationFn, mutationOptions)
}

/**
 * @summary Read Users Me
 */
export const readUsersMeAuthUsersMeGet = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<RoutersAuthUser>> => {
  return axios.get(`/auth/users/me/`, options)
}

export const getReadUsersMeAuthUsersMeGetQueryKey = () => [`/auth/users/me/`]

export type ReadUsersMeAuthUsersMeGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof readUsersMeAuthUsersMeGet>>
>
export type ReadUsersMeAuthUsersMeGetQueryError = AxiosError<unknown>

export const useReadUsersMeAuthUsersMeGet = <
  TData = Awaited<ReturnType<typeof readUsersMeAuthUsersMeGet>>,
  TError = AxiosError<unknown>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof readUsersMeAuthUsersMeGet>>, TError, TData>
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getReadUsersMeAuthUsersMeGetQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof readUsersMeAuthUsersMeGet>>> = ({
    signal
  }) => readUsersMeAuthUsersMeGet({ signal, ...axiosOptions })

  const query = useQuery<Awaited<ReturnType<typeof readUsersMeAuthUsersMeGet>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

/**
 * @summary Read Own Items
 */
export const readOwnItemsAuthUsersMeItemsGet = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<unknown>> => {
  return axios.get(`/auth/users/me/items/`, options)
}

export const getReadOwnItemsAuthUsersMeItemsGetQueryKey = () => [`/auth/users/me/items/`]

export type ReadOwnItemsAuthUsersMeItemsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof readOwnItemsAuthUsersMeItemsGet>>
>
export type ReadOwnItemsAuthUsersMeItemsGetQueryError = AxiosError<unknown>

export const useReadOwnItemsAuthUsersMeItemsGet = <
  TData = Awaited<ReturnType<typeof readOwnItemsAuthUsersMeItemsGet>>,
  TError = AxiosError<unknown>
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof readOwnItemsAuthUsersMeItemsGet>>,
    TError,
    TData
  >
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getReadOwnItemsAuthUsersMeItemsGetQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof readOwnItemsAuthUsersMeItemsGet>>> = ({
    signal
  }) => readOwnItemsAuthUsersMeItemsGet({ signal, ...axiosOptions })

  const query = useQuery<
    Awaited<ReturnType<typeof readOwnItemsAuthUsersMeItemsGet>>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}
