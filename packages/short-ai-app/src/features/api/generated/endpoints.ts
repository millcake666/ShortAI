/**
 * Generated by orval v6.11.1 üç∫
 * Do not edit manually.
 * ShortAI
 * OpenAPI spec version: 0.1.0
 */
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query'
import { useMutation, useQuery } from '@tanstack/react-query'
import type { AxiosError, AxiosRequestConfig, AxiosResponse } from 'axios'
import axios from 'axios'

import type {
  BodyLoginForAccessTokenTokenPost,
  BodyUploadFileTasksTaskIdFilePost,
  DefaultHttpException,
  HTTPValidationError,
  TaskIn,
  TaskOut,
  Token,
  User,
  UserCreate
} from './models'

/**
 * @summary Get User
 */
export const getUserUserGet = (options?: AxiosRequestConfig): Promise<AxiosResponse<unknown>> => {
  return axios.get(`/user`, options)
}

export const getGetUserUserGetQueryKey = () => [`/user`]

export type GetUserUserGetQueryResult = NonNullable<Awaited<ReturnType<typeof getUserUserGet>>>
export type GetUserUserGetQueryError = AxiosError<void>

export const useGetUserUserGet = <
  TData = Awaited<ReturnType<typeof getUserUserGet>>,
  TError = AxiosError<void>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getUserUserGet>>, TError, TData>
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetUserUserGetQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserUserGet>>> = ({ signal }) =>
    getUserUserGet({ signal, ...axiosOptions })

  const query = useQuery<Awaited<ReturnType<typeof getUserUserGet>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

/**
 * @summary Create User
 */
export const createUserUserPost = (
  userCreate: UserCreate,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<Token>> => {
  return axios.post(`/user`, userCreate, options)
}

export type CreateUserUserPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createUserUserPost>>
>
export type CreateUserUserPostMutationBody = UserCreate
export type CreateUserUserPostMutationError = AxiosError<
  DefaultHttpException | void | HTTPValidationError
>

export const useCreateUserUserPost = <
  TError = AxiosError<DefaultHttpException | void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createUserUserPost>>,
    TError,
    { data: UserCreate },
    TContext
  >
  axios?: AxiosRequestConfig
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createUserUserPost>>,
    { data: UserCreate }
  > = (props) => {
    const { data } = props ?? {}

    return createUserUserPost(data, axiosOptions)
  }

  return useMutation<
    Awaited<ReturnType<typeof createUserUserPost>>,
    TError,
    { data: UserCreate },
    TContext
  >(mutationFn, mutationOptions)
}

/**
 * @summary Delete User
 */
export const deleteUserUserDelete = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<unknown>> => {
  return axios.delete(`/user`, options)
}

export type DeleteUserUserDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteUserUserDelete>>
>

export type DeleteUserUserDeleteMutationError = AxiosError<void>

export const useDeleteUserUserDelete = <
  TError = AxiosError<void>,
  TVariables = void,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteUserUserDelete>>,
    TError,
    TVariables,
    TContext
  >
  axios?: AxiosRequestConfig
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteUserUserDelete>>,
    TVariables
  > = () => {
    return deleteUserUserDelete(axiosOptions)
  }

  return useMutation<
    Awaited<ReturnType<typeof deleteUserUserDelete>>,
    TError,
    TVariables,
    TContext
  >(mutationFn, mutationOptions)
}

/**
 * @summary Update User
 */
export const updateUserUserPatch = (
  user: User,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<unknown>> => {
  return axios.patch(`/user`, user, options)
}

export type UpdateUserUserPatchMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateUserUserPatch>>
>
export type UpdateUserUserPatchMutationBody = User
export type UpdateUserUserPatchMutationError = AxiosError<void | HTTPValidationError>

export const useUpdateUserUserPatch = <
  TError = AxiosError<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateUserUserPatch>>,
    TError,
    { data: User },
    TContext
  >
  axios?: AxiosRequestConfig
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateUserUserPatch>>,
    { data: User }
  > = (props) => {
    const { data } = props ?? {}

    return updateUserUserPatch(data, axiosOptions)
  }

  return useMutation<
    Awaited<ReturnType<typeof updateUserUserPatch>>,
    TError,
    { data: User },
    TContext
  >(mutationFn, mutationOptions)
}

/**
 * @summary Check Possibility Of Creating User
 */
export const checkPossibilityOfCreatingUserUserCheckPost = (
  user: User,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<unknown>> => {
  return axios.post(`/user/check`, user, options)
}

export type CheckPossibilityOfCreatingUserUserCheckPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof checkPossibilityOfCreatingUserUserCheckPost>>
>
export type CheckPossibilityOfCreatingUserUserCheckPostMutationBody = User
export type CheckPossibilityOfCreatingUserUserCheckPostMutationError =
  AxiosError<void | HTTPValidationError>

export const useCheckPossibilityOfCreatingUserUserCheckPost = <
  TError = AxiosError<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof checkPossibilityOfCreatingUserUserCheckPost>>,
    TError,
    { data: User },
    TContext
  >
  axios?: AxiosRequestConfig
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof checkPossibilityOfCreatingUserUserCheckPost>>,
    { data: User }
  > = (props) => {
    const { data } = props ?? {}

    return checkPossibilityOfCreatingUserUserCheckPost(data, axiosOptions)
  }

  return useMutation<
    Awaited<ReturnType<typeof checkPossibilityOfCreatingUserUserCheckPost>>,
    TError,
    { data: User },
    TContext
  >(mutationFn, mutationOptions)
}

/**
 * @summary Get Tasks
 */
export const getTasksTasksGet = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<TaskOut[]>> => {
  return axios.get(`/tasks`, options)
}

export const getGetTasksTasksGetQueryKey = () => [`/tasks`]

export type GetTasksTasksGetQueryResult = NonNullable<Awaited<ReturnType<typeof getTasksTasksGet>>>
export type GetTasksTasksGetQueryError = AxiosError<
  DefaultHttpException | void | HTTPValidationError
>

export const useGetTasksTasksGet = <
  TData = Awaited<ReturnType<typeof getTasksTasksGet>>,
  TError = AxiosError<DefaultHttpException | void | HTTPValidationError>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getTasksTasksGet>>, TError, TData>
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetTasksTasksGetQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTasksTasksGet>>> = ({ signal }) =>
    getTasksTasksGet({ signal, ...axiosOptions })

  const query = useQuery<Awaited<ReturnType<typeof getTasksTasksGet>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

/**
 * @summary Create Task
 */
export const createTaskTasksPost = (
  taskIn: TaskIn,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<TaskOut>> => {
  return axios.post(`/tasks`, taskIn, options)
}

export type CreateTaskTasksPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createTaskTasksPost>>
>
export type CreateTaskTasksPostMutationBody = TaskIn
export type CreateTaskTasksPostMutationError = AxiosError<
  DefaultHttpException | void | HTTPValidationError
>

export const useCreateTaskTasksPost = <
  TError = AxiosError<DefaultHttpException | void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createTaskTasksPost>>,
    TError,
    { data: TaskIn },
    TContext
  >
  axios?: AxiosRequestConfig
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createTaskTasksPost>>,
    { data: TaskIn }
  > = (props) => {
    const { data } = props ?? {}

    return createTaskTasksPost(data, axiosOptions)
  }

  return useMutation<
    Awaited<ReturnType<typeof createTaskTasksPost>>,
    TError,
    { data: TaskIn },
    TContext
  >(mutationFn, mutationOptions)
}

/**
 * task_id:
 * @summary Get Task
 */
export const getTaskTasksTaskIdGet = (
  taskId: number,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<TaskOut>> => {
  return axios.get(`/tasks/${taskId}`, options)
}

export const getGetTaskTasksTaskIdGetQueryKey = (taskId: number) => [`/tasks/${taskId}`]

export type GetTaskTasksTaskIdGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTaskTasksTaskIdGet>>
>
export type GetTaskTasksTaskIdGetQueryError = AxiosError<
  DefaultHttpException | void | HTTPValidationError
>

export const useGetTaskTasksTaskIdGet = <
  TData = Awaited<ReturnType<typeof getTaskTasksTaskIdGet>>,
  TError = AxiosError<DefaultHttpException | void | HTTPValidationError>
>(
  taskId: number,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getTaskTasksTaskIdGet>>, TError, TData>
    axios?: AxiosRequestConfig
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetTaskTasksTaskIdGetQueryKey(taskId)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTaskTasksTaskIdGet>>> = ({ signal }) =>
    getTaskTasksTaskIdGet(taskId, { signal, ...axiosOptions })

  const query = useQuery<Awaited<ReturnType<typeof getTaskTasksTaskIdGet>>, TError, TData>(
    queryKey,
    queryFn,
    { enabled: !!taskId, ...queryOptions }
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

/**
 * @summary Upload File
 */
export const uploadFileTasksTaskIdFilePost = (
  taskId: number,
  bodyUploadFileTasksTaskIdFilePost: BodyUploadFileTasksTaskIdFilePost,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<unknown>> => {
  const formData = new FormData()
  formData.append('file', bodyUploadFileTasksTaskIdFilePost.file)

  return axios.post(`/tasks/${taskId}/file`, formData, options)
}

export type UploadFileTasksTaskIdFilePostMutationResult = NonNullable<
  Awaited<ReturnType<typeof uploadFileTasksTaskIdFilePost>>
>
export type UploadFileTasksTaskIdFilePostMutationBody = BodyUploadFileTasksTaskIdFilePost
export type UploadFileTasksTaskIdFilePostMutationError = AxiosError<
  DefaultHttpException | void | HTTPValidationError
>

export const useUploadFileTasksTaskIdFilePost = <
  TError = AxiosError<DefaultHttpException | void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof uploadFileTasksTaskIdFilePost>>,
    TError,
    { taskId: number; data: BodyUploadFileTasksTaskIdFilePost },
    TContext
  >
  axios?: AxiosRequestConfig
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof uploadFileTasksTaskIdFilePost>>,
    { taskId: number; data: BodyUploadFileTasksTaskIdFilePost }
  > = (props) => {
    const { taskId, data } = props ?? {}

    return uploadFileTasksTaskIdFilePost(taskId, data, axiosOptions)
  }

  return useMutation<
    Awaited<ReturnType<typeof uploadFileTasksTaskIdFilePost>>,
    TError,
    { taskId: number; data: BodyUploadFileTasksTaskIdFilePost },
    TContext
  >(mutationFn, mutationOptions)
}

/**
 * @summary Login For Access Token
 */
export const loginForAccessTokenTokenPost = (
  bodyLoginForAccessTokenTokenPost: BodyLoginForAccessTokenTokenPost,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<Token>> => {
  const formUrlEncoded = new URLSearchParams()
  if (bodyLoginForAccessTokenTokenPost.grant_type !== undefined) {
    formUrlEncoded.append('grant_type', bodyLoginForAccessTokenTokenPost.grant_type)
  }
  formUrlEncoded.append('username', bodyLoginForAccessTokenTokenPost.username)
  formUrlEncoded.append('password', bodyLoginForAccessTokenTokenPost.password)
  if (bodyLoginForAccessTokenTokenPost.scope !== undefined) {
    formUrlEncoded.append('scope', bodyLoginForAccessTokenTokenPost.scope)
  }
  if (bodyLoginForAccessTokenTokenPost.client_id !== undefined) {
    formUrlEncoded.append('client_id', bodyLoginForAccessTokenTokenPost.client_id)
  }
  if (bodyLoginForAccessTokenTokenPost.client_secret !== undefined) {
    formUrlEncoded.append('client_secret', bodyLoginForAccessTokenTokenPost.client_secret)
  }

  return axios.post(`/token`, formUrlEncoded, options)
}

export type LoginForAccessTokenTokenPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof loginForAccessTokenTokenPost>>
>
export type LoginForAccessTokenTokenPostMutationBody = BodyLoginForAccessTokenTokenPost
export type LoginForAccessTokenTokenPostMutationError = AxiosError<void | HTTPValidationError>

export const useLoginForAccessTokenTokenPost = <
  TError = AxiosError<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof loginForAccessTokenTokenPost>>,
    TError,
    { data: BodyLoginForAccessTokenTokenPost },
    TContext
  >
  axios?: AxiosRequestConfig
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof loginForAccessTokenTokenPost>>,
    { data: BodyLoginForAccessTokenTokenPost }
  > = (props) => {
    const { data } = props ?? {}

    return loginForAccessTokenTokenPost(data, axiosOptions)
  }

  return useMutation<
    Awaited<ReturnType<typeof loginForAccessTokenTokenPost>>,
    TError,
    { data: BodyLoginForAccessTokenTokenPost },
    TContext
  >(mutationFn, mutationOptions)
}

/**
 * @summary Refresh Token
 */
export const refreshTokenRefreshPost = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<Token>> => {
  return axios.post(`/refresh`, undefined, options)
}

export type RefreshTokenRefreshPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof refreshTokenRefreshPost>>
>

export type RefreshTokenRefreshPostMutationError = AxiosError<void | HTTPValidationError>

export const useRefreshTokenRefreshPost = <
  TError = AxiosError<void | HTTPValidationError>,
  TVariables = void,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof refreshTokenRefreshPost>>,
    TError,
    TVariables,
    TContext
  >
  axios?: AxiosRequestConfig
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof refreshTokenRefreshPost>>,
    TVariables
  > = () => {
    return refreshTokenRefreshPost(axiosOptions)
  }

  return useMutation<
    Awaited<ReturnType<typeof refreshTokenRefreshPost>>,
    TError,
    TVariables,
    TContext
  >(mutationFn, mutationOptions)
}
